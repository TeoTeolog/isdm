По результатам выполнения задания создается отчет со скриншотами, листингом скрипта и небольшим описанием хода работы.
Структура отчета: титульный лист, задание, ход работы, вывод.

---

## Задание

1.  Используйте редактор файлов **vi** или **nano** по Вашему выбору. В данном задании необходимо будет выполнять работу с написанием кода из редактора bash-оболочки.
1.  У вас уже есть несколько директорий из предыдущего задания, в которых находятся файлы **cherry_pie.sh**, зайдите в любую на выбор.
1.  Из этой директории примените команду поиска таких же скриптов и выведите на экран результаты. При желании можно сохранить этот список для использования в следующей части задания.
1.  В пустом bash-скрипте (в скрипте **cherry_pie.sh**) внесите изменения согласно заданию:

    1.  Ищет все файлы cherry_pie.sh во всех директориях предыдущего задания (всего 14 директорий - т.е. 14 файлов).
    1.  Все пустые найденные файлы (13 из 14-ти будут пустыми, в 14-м у Вас вносятся изменения по заданию) -- нужно проверить, что они пустые, пройдя по списку обнаруженных файлов -- заменяются на данный запущенный скрипт.
        - Примечание: После первого успешного запуска скрипты cherry_pie.sh не будут пустыми нигде из этих 14 директорий. Значит, копирования не должно происходить. Не указывайте hardcoded-путь самого скрипта.
    1.  В корневом каталоге предыдущего задания, в котором расположены 14 директорий, происходит запись в файл white_lodge.txt по следующей форме:

        > < timestamp > <имя директории> ordered a cherry pie

        > Dale ordered a cherry pie

## Ход работы

1. Используя редактор **nano** открыли **cherry_pie.sh** в директории **Sheriff_Truman** и вписали туда скрипт приведенный в листинге.
2. Написаный bash скрипт, выполняет действия указанные в задании:
   1. Ищет в радительской директории и её поддиректориях файлы с названием **cherry_pie.sh**.
   2. Копирует исходный текст выполняемого скрипта в найденные файлы, если они пусты, и выводит на экран сообщение об этом.
   3. После чего логирует директорию, содержащию файл с исполняемым сриптом, а так же время, когда был выполнен скрипт.

Листинг скрипта:

```sh
#!/bin/bash

search_dir=$(dirname $(pwd))
cherry_pie_files=$(find "$search_dir" -type f -name "cherry_pie.sh")

for file in $cherry_pie_files; do
    if [ ! -s "$file" ]; then
        cp "$0" "$file"
        echo "Updated $file with the current script content."
    fi
done

log_file="$search_dir/white_lodge.txt"
current_dir=$(basename $(pwd))
timestamp=$(date '+%Y-%m-%d %H:%M:%S')
echo "$timestamp $current_dir ordered a cherry pie" >> "$log_file"
```

## Вывод

В ходе работы были изучены особенности работы с относительно позиционироваными файлами в среде bash. Так же были освоены техники обращения к исполняемому скрипту из самого себя. Был написан простейший срипт логирования действий. В процессе работы возникли трудности связанные со специальным символом "/r" в названии файлов (он вероятно попал туда в ходе выполнения предыдущей работы). Из-за наличия этого символа неверно отображался результат работы команды echo подтверждающей копирование файла, а так же логи имеют неидеальный вид.
